## 一、any类型

    1. 函数add()的参数变量x和y，都没有足够的信息，TypeScript 无法推断出它们的类型，就会认为这两个变量和函数返回值的类型都是any
           
    2. TypeScript 提供了一个编译选项noImplicitAny，打开该选项，只要推断出any类型就会报错  tsc --noImplicitAny app.ts

## 二、污染问题

```javascript
let x:any = 'hello';
let y:number;y = x; // 不报错 
y * 123 // 不报错 
y.toFixed() // 不报错
```

1. 上面示例中，变量`x`的类型是`any`，实际的值是一个字符串。变量`y`的类型是`number`，表示这是一个数值变量，但是它被赋值为`x`，这时并不会报错。然后，变量`y`继续进行各种数值运算，TypeScript 也检查不出错误，问题就这样留到运行时才会暴露。
2. 污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用`any`类型的另一个主要原因。

## 三、unknown类型

1. 为了解决`any`类型“污染”其他变量的问题，TypeScript 3.0 引入了unknown类型。unknown跟any类型不同，不能直接赋值给其他类型的变量。

```javascript
let v:unknown = 123;

let v1:boolean = v; // 报错
let v2:number = v; // 报错
```

2. 不能直接调用unknown类型变量的方法和属性

```javascript
let v1:unknown = { foo: 123 };
v1.foo  // 报错

let v2:unknown = 'hello';
v2.trim() // 报错

let v3:unknown = (n = 0) => n + 1;
v3() // 报错
```

3. unknown类型变量仅限于算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符`!`）、`typeof`运算符和`instanceof`运算符这几种，其它运行都会报错。
4. 怎么才能使用`unknown`类型变量呢？`unknown`类型的变量`a`经过`typeof`运算以后，能够确定实际类型是`number`，就能用于加法运算了。这就是“类型缩小”，即将一个不确定的类型缩小为更明确的类型。

```javascript
let a:unknown = 1;
if (typeof a === 'number') {
  let r = a + 10; // 正确
}
```

## 四、never类型

1. 变量`x`的类型是`never`，就不可能赋给它任何值，否则都会报错。

2. `never`类型的使用场景，主要是在一些类型运算之中，保证类型运算的完整性。另外，不可能返回值的函数，返回值的类型就可以写成`never`。
3. never类型的一个重要特点是，可以赋值给任意其它类型。下面示例中，函数`f()`会抛出错误，所以返回值类型可以写成`never`，即不可能返回任何值。各种其他类型的变量都可以赋值为`f()`的运行结果（`never`类型）。

```javascript
function f():never {
  throw new Error('Error');
}

let v1:number = f(); // 不报错
let v2:string = f(); // 不报错
let v3:boolean = f(); // 不报错
```

4. TypeScript 有两个“顶层类型”（`any`和`unknown`），但是“底层类型”只有`never`唯一一个。


























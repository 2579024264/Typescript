## 一、基本类型

### 1. 概述

1. JavaScript 语言（注意，不是 TypeScript）将值分成8种类型。

   - boolean

   - string

   - number

   - bigint

   - symbol

   - object

   - undefined

   - null

2. 注意，上面所有类型的名称都是小写字母，首字母大写的`Number`、`String`、`Boolean`等在 JavaScript 语言中都是内置对象，而不是类型名称。

   另外，undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。

### 2. 包装对象

#### 2.1 包装对象概念

1. JavaScript 的8种类型之中，`undefined`和`null`其实是两个特殊值，`object`属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。

   - boolean

   - string

   - number

   - bigint

   - symbol

2. 所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。

   ```javascript
   'hello'.charAt(1) // 'e'
   ```

   在调用chatAt方法是，字符串会自动转为包装对象，chatAt()方法其实是定义在包装对象上的。

3. 五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即`Symbol()`和`BigInt()`不能作为构造函数使用），但是剩下三种可以。

```javascript
const s = new String('hello');
typeof s // 'object'
s.charAt(1) // 'e'
```

#### 2.2 包装对象类型与字面量类型

1. 由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。

   ```javascript
   'hello' // 字面量
   new String('hello') // 包装对象
   ```

2. TypeScript 对五种原始类型分别提供了大写和小写两种类型。

   - Boolean 和 boolean

   - String 和 string

   - Number 和 number

   - BigInt 和 bigint

   - Symbol 和 symbol

​	其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。

### 3. Object类型与object类型

#### 3.1 Object类型

1. 大写的`Object`类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值（除了undefined和null这个两值不能转为对象），都是`Object`类型，这囊括了几乎所有的值。

```javascript
let obj:Object;
 
obj = true;
obj = 'hi';
obj = 1;
obj = { foo: 123 };
obj = [1, 2];
obj = (a:number) => a + 1;

obj = undefined; // 报错
obj = null; // 报错
```

2. 空对象`{}`是`Object`类型的简写形式，所以使用`Object`时常常用空对象代替。

#### 3.2 object类型

1. 小写的`object`类型只包含对象、数组和函数，不包括原始类型的值。

```javascript
let obj:object;
 
obj = { foo: 123 };
obj = [1, 2];
obj = (a:number) => a + 1;
obj = true; // 报错
obj = 'hi'; // 报错
obj = 1; // 报错
```

2. 无论是大写的`Object`类型，还是小写的`object`类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中

```javascript
const o1:Object = { foo: 0 };
const o2:object = { foo: 0 };

o1.toString() // 正确
o1.foo // 报错

o2.toString() // 正确
o2.foo // 报错
```



### 4. undefined和null的特殊性

1. 在ts中默认情况下 null和undefined可以赋值给任何其他类型的变量。

```javascript
let age:number = 24;

age = null;      // 正确
age = undefined; // 正确
```

2. 但是有时候，这并不是开发者想要的行为，也不利于发挥类型系统的优势。下面示例中，变量`obj`等于`undefined`，编译不会报错。但是，实际执行时，调用`obj.toString()`就报错了，因为`undefined`不是对象，没有这个方法。

```javascript
const obj:object = undefined;
obj.toString() // 编译不报错，运行就报错
```

3. 为了避免这种情况，及早发现错误，TypeScript 提供了一个编译选项`strictNullChecks`。只要打开这个选项，`undefined`和`null`就不能赋值给其他类型的变量（除了`any`类型和`unknown`类型）。

```javascript
{
  "compilerOptions": {
    "strictNullChecks": true
    // ...
  }
}
```

### 

### 5. 值类型

1. 使用const声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。注意：`const`命令声明的变量，如果赋值为对象，并不会推断为值类型。

   ```javascript
   // x 的类型是 "https"
   const x = 'https';
   
   // y 的类型是 string
   const y:string = 'https';
   
   // x 的类型是 { foo: number }
   const x = { foo: 1 };
   ```

2. 下面示例中，变量`x`属于子类型，变量`y`属于父类型。子类型`x`不能赋值为父类型`y`，但是反过来是可以的

   ```javascript
   let x:5 = 5;
   let y:number = 4 + 1;
   
   x = y; // 报错
   y = x; // 正确
   ```



### 6. 联合类型

1. 联合类型指的是多个类型组成的一个新类型，使用符号`|`表示。联合类型可以与值类型相结合，表示一个变量的值有若干种可能。

   ```javascript
   let x:string|number;
   
   let setting:true|false;
   
   let gender:'male'|'female';
   
   let rainbowColor:'赤'|'橙'|'黄'|'绿'|'青'|'蓝'|'紫';
   ```

2. 如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”，区分该值到底属于哪一种类型，然后再进一步处理。

```javascript
function printId(
  id:number|string
) {
  if (typeof id === 'string') {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```



### 7. 交叉类型

1. 交叉类型指的是多个类型组成的一个 新类型，使用符号&表示。交叉类型`A&B`表示，任何一个类型必须同时属于`A`和`B`，才属于交叉类型`A&B`

2. 交叉类型的主要用途是表示对象的合成。

   ```javascript
   let obj:
     { foo: string } &
     { bar: string };
   
   obj = {
     foo: 'hello',
     bar: 'world'
   };
   ```

3. 交叉类型常常用来为对象类型添加新属性。

   ```javascript
   type A = { foo: number };
   
   type B = A & { bar: number };
   ```



### 8. type命令

1. type命令用来定义一个类型的别名

   ```javascript
   type Age = number;
   
   let age:Age = 55;
   ```

2. 别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。

   ```javascript
   type Color = 'red';
   
   if (Math.random() < 0.5) {
     type Color = 'blue';
   }
   ```

### 9. typeof运算符

1. JavaScript 里面，`typeof`运算符只可能返回八种结果，而且都是字符串。
2. TypeScript 将`typeof`运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。

```javascript
let a = 1;
let b:typeof a;

if (typeof a === 'number') {
  b = a;
}
```

3. typeof不能用作以下两种情况

```typescript
type T = typeof Date(); // 报错 typeof参数只能是标识符，不能是需要运算的表达式

type Age = number;
type MyAge = typeof Age; // 报错 typeof参数不能是类型 这里Age是一个类型别名
```

### 10. 块级类型声明

1. TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。

```typescript
if (true) {
  type T = number;
  let v:T = 5;
} else {
  type T = string;
  let v:T = 'hello';
}
```

### 11. 类型的兼容

1. TypeScript 为这种情况定义了一个专门术语。如果类型`A`的值可以赋值给类型`B`，那么类型`A`就称为类型`B`的子类型（subtype）。在下例中，类型`number`就是类型`number|string`的子类型。

```typescript
type T = number|string;

let a:number = 1;
let b:T = a;
```

```typescript
let a:'hi' = 'hi';
let b:string = 'hello';

b = a; // 正确
a = b; // 报错
```
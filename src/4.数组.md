### 1. 简介

1. TypeScript 数组所有成员的类型必须相同,数组的类型有两种写法

```typescript
// 第一种写法
let arr:number[] = [1, 2, 3];
let arr:(number|string)[];

// 第二种写法 使用Typescript内置的Array接口 泛型写法
let arr:Array<number> = [1, 2, 3];
let arr:Array<number|string>;
```

2. TypeScript允许使用方括号读取数组成员的类型

```typescript
type Names = string[];
type Name = Names[0]; // string
// 由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样
type Name = Names[number]; // string
```

### 2. 数组的类型推断

1. 如果数组变量没有声明类型，TypeScript 就会推断数组成员的类型
2. 数组变量`arr`的初始值是空数组，TypeScript 会自动修改推断的数组类型。

```typescript
const arr = [];
arr // 推断为 any[]

arr.push(123);
arr // 推断类型为 number[]

arr.push('abc');
arr // 推断类型为 (string|number)[]
```

3. 类型推断的自动更新只发生初始值为空数组的情况。如果初始值不是空数组，类型推断就不会更新。

```typescript
// 推断类型为 number[]
const arr = [123];

arr.push('abc'); // 报错
```

### 3. 只读数组，const断言

1. TypeScript 将`readonly number[]`与`number[]`视为两种不一样的类型，后者是前者的子类型。

```typescript
function getSum(s:number[]) {
  // ...
}

const arr:readonly number[] = [1, 2, 3];

getSum(arr) // 报错
```

2. `readonly`与数组的泛型写法一起使用，就会报错。TypeScript 提供了两个专门的泛型，用来生成只读数组的类型

```typescript
// 报错
const arr:readonly Array<number> = [0, 1];

const a1:ReadonlyArray<number> = [0, 1];

const a2:Readonly<number[]> = [0, 1];

```

3. 只读数组还有一种声明方法，就是使用“const 断言”。

```typescript
const arr = [0, 1] as const;

arr[0] = [2]; // 报错 
```

### 4. 多维数组

TypeScript 使用`T[][]`的形式，表示二维数组，`T`是最底层数组成员的类型。

```typescript
var multi:number[][] = [[1,2,3], [23,24,25]];// 最底层的数组成员类型是number。
```

